# æ–‡ä»¶ç³»ç»Ÿï¼Œç¬¬ 9 éƒ¨åˆ†ï¼šç£ç›˜å—ç¤ºä¾‹

> åŸæ–‡ï¼š<https://github.com/angrave/SystemProgramming/wiki/File-System%2C-Part-9%3A-Disk-blocks-example>

## æ­£åœ¨æ–½å·¥ğŸš§

## è¯·é—®æ‚¨èƒ½è§£é‡Šä¸€ä¸‹æ–‡ä»¶å†…å®¹å¦‚ä½•å­˜å‚¨åœ¨ç®€å•çš„åŸºäº i èŠ‚ç‚¹çš„æ–‡ä»¶ç³»ç»Ÿä¸­çš„ç®€å•æ¨¡å‹å—ï¼Ÿ

å½“ç„¶ï¼è¦å›ç­”è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªè™šæ‹Ÿç£ç›˜ï¼Œç„¶åç¼–å†™ä¸€äº› C ä»£ç æ¥è®¿é—®å…¶å†…å®¹ã€‚æˆ‘ä»¬çš„æ–‡ä»¶ç³»ç»Ÿå°†å¯ç”¨å­—èŠ‚åˆ’åˆ†ä¸º inode çš„ç©ºé—´å’Œç£ç›˜å—çš„æ›´å¤§ç©ºé—´ã€‚æ¯ä¸ªç£ç›˜å—å°†ä¸º 4096 å­—èŠ‚ -

```c
// Disk size:
#define MAX_INODE (1024)
#define MAX_BLOCK (1024*1024)

// Each block is 4096 bytes:
typedef char[4096] block_t;

// A disk is an array of inodes and an array of disk blocks:
struct inode[MAX_INODE] inodes;
block[MAX_BLOCK] blocks;
```

è¯·æ³¨æ„ï¼Œä¸ºäº†æ¸…æ¥šèµ·è§ï¼Œæˆ‘ä»¬ä¸ä¼šåœ¨æ­¤ä»£ç ç¤ºä¾‹ä¸­ä½¿ç”¨â€œunsignedâ€ã€‚æˆ‘ä»¬çš„å›ºå®šå¤§å°çš„ inode å°†åŒ…å«æ–‡ä»¶çš„å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ï¼Œæƒé™ï¼Œç”¨æˆ·ï¼Œç»„ä¿¡æ¯ï¼Œæ—¶é—´å…ƒæ•°æ®ã€‚ä¸é—®é¢˜æœ€ç›¸å…³çš„æ˜¯å®ƒè¿˜åŒ…æ‹¬åä¸ªæŒ‡å‘ç£ç›˜å—çš„æŒ‡é’ˆï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¿™äº›æŒ‡é’ˆæ¥å¼•ç”¨å®é™…æ–‡ä»¶çš„å†…å®¹ï¼

```c
struct inode {
 int[10] directblocks; // indices for the block array i.e. where to the find the file's content
 long size;
 // ... standard inode meta-data e.g.
 int mode, userid,groupid;
 time_t ctime,atime,mtime;
}
```

ç°åœ¨æˆ‘ä»¬å¯ä»¥å¼„æ¸…æ¥šå¦‚ä½•è¯»å–æ–‡ä»¶åç§»é‡`position`çš„å­—èŠ‚ï¼š

```c
char readbyte(inode*inode,long position) {
  if(position <0 || position >= inode->size) return -1; // invalid offset

  int  block_count = position / 4096,offset = position % 4096;

  // block count better be 0..9 !
  int physical_idx = lookup_physical_block_index(inode, block_count );

  // sanity check that the disk block index is reasonable...
  assert(physical_idx >=0 && physical_idx < MAX_BLOCK);

  // read the disk block from our virtual disk 'blocks' and return the specific byte
  return blocks[physical_idx][offset];
}
```

æˆ‘ä»¬çš„ lookup_physical_block çš„åˆå§‹ç‰ˆæœ¬å¾ˆç®€å• - æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ 10 ä¸ªç›´æ¥å—çš„è¡¨æ ¼ï¼

```c
int lookup_physical_block_index(inode*inode, int block_count) {
  assert(block_count>=0 && block_count < 10);

  return inode->directblocks[ block_count ]; // returns an index value between [0,MAX_BLOCK)
}
```

è¿™ç§ç®€å•çš„è¡¨ç¤ºæ˜¯åˆç†çš„ï¼Œåªè¦æˆ‘ä»¬å¯ä»¥ç”¨åä¸ªå—è¡¨ç¤ºæ‰€æœ‰å¯èƒ½çš„æ–‡ä»¶ï¼Œå³æœ€å¤š 40KBã€‚å¤§æ–‡ä»¶æ€ä¹ˆæ ·ï¼Ÿæˆ‘ä»¬éœ€è¦ inode ç»“æ„å§‹ç»ˆå…·æœ‰ç›¸åŒçš„å¤§å°ï¼Œå› æ­¤å°†ç°æœ‰çš„ç›´æ¥å—æ•°ç»„å¢åŠ åˆ° 20 å°†å¤§çº¦æ˜¯æˆ‘ä»¬çš„ inode å¤§å°çš„ä¸¤å€ã€‚å¦‚æœæˆ‘ä»¬çš„å¤§å¤šæ•°æ–‡ä»¶éœ€è¦å°‘äº 10 ä¸ªå—ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„ inode å­˜å‚¨ç°åœ¨æ˜¯æµªè´¹çš„ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªåä¸º _ é—´æ¥å— _ çš„ç£ç›˜å—æ¥æ‰©å±•æŒ‡é’ˆæ•°ç»„ã€‚æˆ‘ä»¬åªéœ€è¦è¿™ä¸ªæ–‡ä»¶ï¼†gt; 40KB

```c
struct inode {
 int[10] directblocks; // if size<4KB then only the first one is valid
 int indirectblock; // valid value when size >= 40KB
 int size;
 ...
}
```

é—´æ¥å—åªæ˜¯ä¸€ä¸ª 4096 å­—èŠ‚çš„å¸¸è§„ç£ç›˜å—ï¼Œä½†æˆ‘ä»¬å°†ä½¿ç”¨å®ƒæ¥ä¿å­˜æŒ‡å‘ç£ç›˜å—çš„æŒ‡é’ˆã€‚åœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬çš„æŒ‡é’ˆåªæ˜¯æ•´æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å°†æŒ‡é’ˆå¼ºåˆ¶è½¬æ¢ä¸ºæ•´æ•°æŒ‡é’ˆï¼š

```c
int lookup_physical_block_index(inode*inode, int block_count) {
  assert(sizeof(int)==4); // Warning this code assumes an index is 4 bytes!
  assert(block_count>=0 && block_count < 1024 + 10); // 0 <= block_count< 1034

  if( block_count < 10)
     return inode->directblocks[ block_count ];

  // read the indirect block from disk:
  block_t* oneblock = & blocks[ inode->indirectblock ];

  // Treat the 4KB as an array of 1024 pointers to other disk blocks
  int* table = (int*) oneblock;

 // Look up the correct entry in the table
 // Offset by 10 because the first 10 blocks of data are already 
 // accounted for
  return table[ block_count - 10 ];
}
```

å¯¹äºå…¸å‹çš„æ–‡ä»¶ç³»ç»Ÿï¼Œæˆ‘ä»¬çš„ç´¢å¼•å€¼æ˜¯ 32 ä½ï¼Œå³ 4 å­—èŠ‚ã€‚å› æ­¤ï¼Œåœ¨ 4096 å­—èŠ‚ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å­˜å‚¨ 4096/4 = 1024 ä¸ªæ¡ç›®ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬çš„é—´æ¥å—å¯ä»¥å¼•ç”¨ 1024 * 4KB = 4MB çš„æ•°æ®ã€‚é€šè¿‡å‰åä¸ªç›´æ¥å—ï¼Œæˆ‘ä»¬å¯ä»¥å®¹çº³æœ€å¤§ 40KB + 1024 * 4KB = 4136KB çš„æ–‡ä»¶ã€‚å¯¹äºå°äºæ­¤å€¼çš„æ–‡ä»¶ï¼ŒæŸäº›åç»­è¡¨æ¡ç›®å¯èƒ½æ— æ•ˆã€‚

å¯¹äºæ›´å¤§çš„æ–‡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªé—´æ¥å—ã€‚ç„¶è€Œï¼Œæœ‰ä¸€ä¸ªæ›´å¥½çš„é€‰æ‹©ï¼Œè¿™å°†å…è®¸æˆ‘ä»¬æœ‰æ•ˆåœ°æ‰©å±•åˆ°å¤§å‹æ–‡ä»¶ã€‚æˆ‘ä»¬å°†åŒ…å«ä¸€ä¸ªåŒé—´æ¥æŒ‡é’ˆï¼Œå¦‚æœè¿™è¿˜ä¸å¤Ÿä¸‰é‡é—´æ¥æŒ‡é’ˆã€‚åŒé‡é—´æ¥æŒ‡é’ˆæ„å‘³ç€æˆ‘ä»¬æœ‰ä¸€ä¸ª 1024 ä¸ªæ¡ç›®è¡¨åˆ°ç£ç›˜å—ï¼Œç”¨ä½œ 1024 ä¸ªæ¡ç›®ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥å‚è€ƒ 1024 * 1024 ä¸ªç£ç›˜æ•°æ®å—ã€‚

![inode disk blocks for data](img/c012049198839822b4b9b3716bf1ddff.jpg)

ï¼ˆæ¥æºï¼š [http://uw714doc.sco.com/en/FS_admin/graphics/s5chain.gif](http://uw714doc.sco.com/en/FS_admin/graphics/s5chain.gif) ï¼‰

```c
int lookup_physical_block_index(inode*inode, int block_count) {
  if( block_count < 10)
     return inode->directblocks[ block_count ];

  // Use indirect block for the next 1024 blocks:
  // Assumes 1024 ints can fit inside each block!
  if( block_count < 1024 + 10) {   
      int* table = (int*) & blocks[ inode->indirectblock ];
      return table[ block_count - 10 ];
  }
  // For huge files we will use a table of tables
  int i = (block_count - 1034) / 1024 , j = (block_count - 1034) % 1024;
  assert(i<1024); // triple-indirect is not implemented here!

  int* table1 = (int*) & blocks[ inode->doubleindirectblock ];
   // The first table tells us where to read the second table ...
  int* table2 = (int*) & blocks[   table1[i]   ];
  return table2[j];

   // For gigantic files we will need to implement triple-indirect (table of tables of tables)
}
```

è¯·æ³¨æ„ï¼Œä½¿ç”¨ double indirect è¯»å–å­—èŠ‚éœ€è¦ 3 ä¸ªç£ç›˜å—è¯»å–ï¼ˆä¸¤ä¸ªè¡¨å’Œå®é™…æ•°æ®å—ï¼‰ã€‚