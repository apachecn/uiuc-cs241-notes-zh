# 调度，第2部分：调度过程：算法

> 原文：<https://github.com/angrave/SystemProgramming/wiki/Scheduling%2C-Part-2%3A-Scheduling-Processes%3A-Algorithms>

## 什么是众所周知的调度算法？

对于所有的例子，

过程1：运行时1000ms

过程2：运行时2000ms

过程3：运行时3000ms

过程4：运行时4000ms

过程5：运行时5000ms

## 最短的工作优先（SJF）

![](img/aacd324af23dbabdf0c8511652cfadb2.jpg)

*   P1到达：0ms
*   P2到达：0ms
*   P3到达：0ms
*   P4到达：0ms
*   P5到货：0ms

这些进程都在开始时到达，并且调度程序以最短的总CPU时间调度作业。明显的问题是这个调度程序需要知道该程序在运行程序之前将持续运行多长时间。

技术说明：实际的SJF实现不会使用进程的总执行时间，而是使用突发时间（包括将来计算执行之前的总CPU时间将不再准备好运行）。可以通过使用基于先前突发时间的指数衰减加权滚动平均来估计预期突发时间，但是对于该展示，我们将简化该讨论以使用该过程的总运行时间作为突发时间的代理。

**优势**

*   较短的工作往往先运行

**缺点**

*   需要算法是无所不知的

## 抢先最短的工作优先（PSJF）

先抢先最短的作业首先是最短的作业，但是如果新作业的运行时间短于过程的剩余运行时间，则运行该作业。 （如果它与我们的算法相同，我们的算法可以选择）。调度程序使用进程的总运行时间，如果你想剩下最短_剩余_时间，那就是PSJF的变体，称为Shortest Remaining Time First。

![](img/a939273ec986aaa3938cdbe2867a08e2.jpg)

*   P2在0ms
*   P1在1000ms
*   P5在3000ms
*   P4在4000ms
*   P3在5000ms

这是我们的算法所做的。它运行P2因为它是唯一运行的东西。然后P1进入1000ms，P2运行2000ms，所以我们的调度程序先发制人地停止P2，让P1一直运行（这完全取决于算法因为时间相等）。然后，P5进入 - 由于没有进程正在运行，调度程序将运行进程5.P4进入，并且由于运行时间等于P5，调度程序停止P5并运行P4。最后P3进入，抢占P4，并运行完成。然后P4运行，然后P5运行。

**Advantages**

*   确保较短的工作首先运行

**Disadvantages**

*   需要再次了解运行时

**注意：**此算法因历史原因比较总运行时间_而非_剩余运行时间。如果您想考虑剩余时间，您将使用抢先最短剩余时间优先（PSRTF）。

## 先到先得（FCFS）

![](img/3332236e74b2fb5bdc6e33bec4ce909e.jpg)

*   P2在0ms
*   P1在1000ms
*   P5在3000ms
*   P4在4000ms
*   P3在5000ms

流程按到达顺序安排。 FCFS的一个优点是调度算法很简单：就绪队列只是一个FIFO（先进先出）队列。 FCFS遭遇康宏效应。

在这里P2到达，然后P1到达，然后是P5，然后是P4，然后是P3。你可以看到P5的护航效果。

**Advantages**

*   简单的实施

**Disadvantages**

*   长时间运行的进程可以阻止所有其他进程

## Round Robin（RR）

进程按其到达就绪队列的顺序进行安排。但是，经过一小段时间后，将强制从运行状态中删除正在运行的进程并将其放回就绪队列。这可确保长时间运行的进程不会使所有其他进程无法运行。进程在返回就绪队列之前可以执行的最长时间称为时间量。在大时间量子点（时间量子长于所有过程的运行时间）的限制下，循环将等同于FCFS。

![](img/332fa7df9feb67953e1554176b74fd84.jpg)

*   P1到达：0ms
*   P2到达：0ms
*   P3到达：0ms
*   P4到达：0ms
*   P5到货：0ms

量子= 1000ms

这里所有流程都在同一时间到达。 P1运行1个量程并完成。 P2为一个量子;然后，P3停止了。在为量子运行所有其他进程之后，我们循环回到P2，直到完成所有进程。

**Advantages**

*   确保一些公平的概念

**Disadvantages**

*   大量进程=大量切换

## 优先

进程按优先级顺序排列。例如，导航过程执行可能比记录过程更重要。